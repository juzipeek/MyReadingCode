<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<!-- code.jsp -->


<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>sun.tools.jconsole: Plotter.java</title>
</head>
<body style="padding:0 0 0 0;margin:0 0 0 0">
<div style="width:100%;background-color:#ddeeff;border:1px solid #ccddee;margin:0 0 0 0;padding:2px 2px 2px 2px">
<div style="float:right"><a href="http://del.icio.us/post" onclick="window.open('http://del.icio.us/post?v=4&noui&jump=close&url='+encodeURIComponent(location.href)+'&title='+encodeURIComponent(document.title), 'delicious','toolbar=no,width=700,height=400'); return false;"><img src="http://images.del.icio.us/static/img/delicious.small.gif" border=0> Save This Page</a></div>
<a href="/">Home</a> &#187; <a href="/projects/openjdk-7-code.html">openjdk-7</a> &#187; sun.tools &#187;  <a href='/docs/api/sun/tools/jconsole/package-index.html'>jconsole</a> &#187; 
 [<a href="/docs/api/sun/tools/jconsole/Plotter.html">javadoc</a> | source]
</div>
<pre>
<a name='1'>    1 &nbsp; /*
    2 &nbsp;  * Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved.
    3 &nbsp;  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 &nbsp;  *
    5 &nbsp;  * This code is free software; you can redistribute it and/or modify it
    6 &nbsp;  * under the terms of the GNU General Public License version 2 only, as
    7 &nbsp;  * published by the Free Software Foundation.  Oracle designates this
    8 &nbsp;  * particular file as subject to the "Classpath" exception as provided
    9 &nbsp;  * by Oracle in the LICENSE file that accompanied this code.
   10 &nbsp;  *
<a name='11'>   11 &nbsp;  * This code is distributed in the hope that it will be useful, but WITHOUT
   12 &nbsp;  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   13 &nbsp;  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   14 &nbsp;  * version 2 for more details (a copy is included in the LICENSE file that
   15 &nbsp;  * accompanied this code).
   16 &nbsp;  *
   17 &nbsp;  * You should have received a copy of the GNU General Public License version
   18 &nbsp;  * 2 along with this work; if not, write to the Free Software Foundation,
   19 &nbsp;  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   20 &nbsp;  *
<a name='21'>   21 &nbsp;  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   22 &nbsp;  * or visit www.oracle.com if you need additional information or have any
   23 &nbsp;  * questions.
   24 &nbsp;  */
   25 &nbsp; 
   26 &nbsp; <span class='kw'>package</span> <a href=/docs/api/sun/tools/jconsole/package-index.html>sun.tools.jconsole</a>;
   27 &nbsp; 
   28 &nbsp; <span class='kw'>import</span> <a href=/docs/api/java/awt/package-index.html>java.awt</a>;
   29 &nbsp; <span class='kw'>import</span> <a href=/docs/api/java/awt/event/package-index.html>java.awt.event</a>;
   30 &nbsp; <span class='kw'>import</span> <a href=/docs/api/java/beans/package-index.html>java.beans</a>;
<a name='31'>   31 &nbsp; <span class='kw'>import</span> <a href=/docs/api/java/io/package-index.html>java.io</a>;
   32 &nbsp; <span class='kw'>import</span> <a href=/docs/api/java/lang/reflect/Array.html>java.lang.reflect.Array</a>;
   33 &nbsp; <span class='kw'>import</span> <a href=/docs/api/java/util/package-index.html>java.util</a>;
   34 &nbsp; 
   35 &nbsp; <span class='kw'>import</span> <a href=/docs/api/javax/accessibility/package-index.html>javax.accessibility</a>;
   36 &nbsp; <span class='kw'>import</span> <a href=/docs/api/javax/swing/package-index.html>javax.swing</a>;
   37 &nbsp; <span class='kw'>import</span> <a href=/docs/api/javax/swing/border/package-index.html>javax.swing.border</a>;
   38 &nbsp; <span class='kw'>import</span> <a href=/docs/api/javax/swing/filechooser/package-index.html>javax.swing.filechooser</a>;
   39 &nbsp; <span class='kw'>import</span> <a href=/docs/api/javax/swing/filechooser/FileFilter.html>javax.swing.filechooser.FileFilter</a>;
   40 &nbsp; 
<a name='41'>   41 &nbsp; <span class='kw'>import</span> <a href=/docs/api/com/sun/tools/jconsole/JConsoleContext.html>com.sun.tools.jconsole.JConsoleContext</a>;
   42 &nbsp; 
   43 &nbsp; import static com.sun.tools.jconsole.JConsoleContext.ConnectionState.*;
   44 &nbsp; 
   45 &nbsp; import static sun.tools.jconsole.Formatter.*;
   46 &nbsp; import static sun.tools.jconsole.ProxyClient.*;
   47 &nbsp; import static sun.tools.jconsole.Resources.*;
   48 &nbsp; import static sun.tools.jconsole.Utilities.*;
   49 &nbsp; 
   50 &nbsp; @SuppressWarnings("serial")
<a name='51'>   51 &nbsp; public class Plotter extends JComponent
   52 &nbsp;                      implements Accessible, ActionListener, PropertyChangeListener {
   53 &nbsp; 
   54 &nbsp;     public static enum Unit {
   55 &nbsp;         NONE, BYTES, PERCENT
   56 &nbsp;     }
   57 &nbsp; 
   58 &nbsp;     static final String[] rangeNames = {
   59 &nbsp;         Resources.getText(" 1 min"),
   60 &nbsp;         Resources.getText(" 5 min"),
<a name='61'>   61 &nbsp;         Resources.getText("10 min"),
   62 &nbsp;         Resources.getText("30 min"),
   63 &nbsp;         Resources.getText(" 1 hour"),
   64 &nbsp;         Resources.getText(" 2 hours"),
   65 &nbsp;         Resources.getText(" 3 hours"),
   66 &nbsp;         Resources.getText(" 6 hours"),
   67 &nbsp;         Resources.getText("12 hours"),
   68 &nbsp;         Resources.getText(" 1 day"),
   69 &nbsp;         Resources.getText(" 7 days"),
   70 &nbsp;         Resources.getText(" 1 month"),
<a name='71'>   71 &nbsp;         Resources.getText(" 3 months"),
   72 &nbsp;         Resources.getText(" 6 months"),
   73 &nbsp;         Resources.getText(" 1 year"),
   74 &nbsp;         Resources.getText("All")
   75 &nbsp;     };
   76 &nbsp; 
   77 &nbsp;     static final int[] rangeValues = {
   78 &nbsp;         1,
   79 &nbsp;         5,
   80 &nbsp;         10,
<a name='81'>   81 &nbsp;         30,
   82 &nbsp;         1 * 60,
   83 &nbsp;         2 * 60,
   84 &nbsp;         3 * 60,
   85 &nbsp;         6 * 60,
   86 &nbsp;         12 * 60,
   87 &nbsp;         1 * 24 * 60,
   88 &nbsp;         7 * 24 * 60,
   89 &nbsp;         1 * 31 * 24 * 60,
   90 &nbsp;         3 * 31 * 24 * 60,
<a name='91'>   91 &nbsp;         6 * 31 * 24 * 60,
   92 &nbsp;         366 * 24 * 60,
   93 &nbsp;         -1
   94 &nbsp;     };
   95 &nbsp; 
   96 &nbsp; 
   97 &nbsp;     final static long SECOND = 1000;
   98 &nbsp;     final static long MINUTE = 60 * SECOND;
   99 &nbsp;     final static long HOUR   = 60 * MINUTE;
  100 &nbsp;     final static long DAY    = 24 * HOUR;
<a name='101'>  101 &nbsp; 
  102 &nbsp;     final static Color bgColor = new Color(250, 250, 250);
  103 &nbsp;     final static Color defaultColor = Color.blue.darker();
  104 &nbsp; 
  105 &nbsp;     final static int ARRAY_SIZE_INCREMENT = 4000;
  106 &nbsp; 
  107 &nbsp;     private static Stroke dashedStroke;
  108 &nbsp; 
  109 &nbsp;     private TimeStamps times = new TimeStamps();
  110 &nbsp;     private ArrayList&lt;Sequence&gt; seqs = new ArrayList&lt;Sequence&gt;();
<a name='111'>  111 &nbsp;     private JPopupMenu popupMenu;
  112 &nbsp;     private JMenu timeRangeMenu;
  113 &nbsp;     private JRadioButtonMenuItem[] menuRBs;
  114 &nbsp;     private JMenuItem saveAsMI;
  115 &nbsp;     private JFileChooser saveFC;
  116 &nbsp; 
  117 &nbsp;     private int viewRange = -1; // Minutes (value &lt;= 0 means full range)
  118 &nbsp;     private Unit unit;
  119 &nbsp;     private int decimals;
  120 &nbsp;     private double decimalsMultiplier;
<a name='121'>  121 &nbsp;     private Border border = null;
  122 &nbsp;     private Rectangle r = new Rectangle(1, 1, 1, 1);
  123 &nbsp;     private Font smallFont = null;
  124 &nbsp; 
  125 &nbsp;     // Initial margins, may be recalculated as needed
  126 &nbsp;     private int topMargin = 10;
  127 &nbsp;     private int bottomMargin = 45;
  128 &nbsp;     private int leftMargin = 65;
  129 &nbsp;     private int rightMargin = 70;
  130 &nbsp;     private final boolean displayLegend;
<a name='131'>  131 &nbsp; 
  132 &nbsp;     public Plotter() {
  133 &nbsp;         this(Unit.NONE, 0);
  134 &nbsp;     }
  135 &nbsp; 
  136 &nbsp;     public Plotter(Unit unit) {
  137 &nbsp;         this(unit, 0);
  138 &nbsp;     }
  139 &nbsp; 
  140 &nbsp;     public Plotter(Unit unit, int decimals) {
<a name='141'>  141 &nbsp;         this(unit,decimals,true);
  142 &nbsp;     }
  143 &nbsp; 
  144 &nbsp;     // Note: If decimals &gt; 0 then values must be decimally shifted left
  145 &nbsp;     // that many places, i.e. multiplied by Math.pow(10.0, decimals).
  146 &nbsp;     public Plotter(Unit unit, int decimals, boolean displayLegend) {
  147 &nbsp;         this.displayLegend = displayLegend;
  148 &nbsp;         setUnit(unit);
  149 &nbsp;         setDecimals(decimals);
  150 &nbsp; 
<a name='151'>  151 &nbsp;         enableEvents(AWTEvent.MOUSE_EVENT_MASK);
  152 &nbsp; 
  153 &nbsp;         addMouseListener(new MouseAdapter() {
  154 &nbsp;             @Override
  155 &nbsp;             public void mousePressed(MouseEvent e) {
  156 &nbsp;                 if (getParent() instanceof PlotterPanel) {
  157 &nbsp;                     getParent().requestFocusInWindow();
  158 &nbsp;                 }
  159 &nbsp;             }
  160 &nbsp;         });
<a name='161'>  161 &nbsp; 
  162 &nbsp;     }
  163 &nbsp; 
  164 &nbsp;     public void setUnit(Unit unit) {
  165 &nbsp;         this.unit = unit;
  166 &nbsp;     }
  167 &nbsp; 
  168 &nbsp;     public void setDecimals(int decimals) {
  169 &nbsp;         this.decimals = decimals;
  170 &nbsp;         this.decimalsMultiplier = Math.pow(10.0, decimals);
<a name='171'>  171 &nbsp;     }
  172 &nbsp; 
  173 &nbsp;     public void createSequence(String key, String name, Color color, boolean isPlotted) {
  174 &nbsp;         Sequence seq = getSequence(key);
  175 &nbsp;         if (seq == null) {
  176 &nbsp;             seq = new Sequence(key);
  177 &nbsp;         }
  178 &nbsp;         seq.name = name;
  179 &nbsp;         seq.color = (color != null) ? color : defaultColor;
  180 &nbsp;         seq.isPlotted = isPlotted;
<a name='181'>  181 &nbsp; 
  182 &nbsp;         seqs.add(seq);
  183 &nbsp;     }
  184 &nbsp; 
  185 &nbsp;     public void setUseDashedTransitions(String key, boolean b) {
  186 &nbsp;         Sequence seq = getSequence(key);
  187 &nbsp;         if (seq != null) {
  188 &nbsp;             seq.transitionStroke = b ? getDashedStroke() : null;
  189 &nbsp;         }
  190 &nbsp;     }
<a name='191'>  191 &nbsp; 
  192 &nbsp;     public void setIsPlotted(String key, boolean isPlotted) {
  193 &nbsp;         Sequence seq = getSequence(key);
  194 &nbsp;         if (seq != null) {
  195 &nbsp;             seq.isPlotted = isPlotted;
  196 &nbsp;         }
  197 &nbsp;     }
  198 &nbsp; 
  199 &nbsp;     // Note: If decimals &gt; 0 then values must be decimally shifted left
  200 &nbsp;     // that many places, i.e. multiplied by Math.pow(10.0, decimals).
<a name='201'>  201 &nbsp;     public synchronized void addValues(long time, long... values) {
  202 &nbsp;         assert (values.length == seqs.size());
  203 &nbsp;         times.add(time);
  204 &nbsp;         for (int i = 0; i &lt; values.length; i++) {
  205 &nbsp;             seqs.get(i).add(values[i]);
  206 &nbsp;         }
  207 &nbsp;         repaint();
  208 &nbsp;     }
  209 &nbsp; 
  210 &nbsp;     private Sequence getSequence(String key) {
<a name='211'>  211 &nbsp;         for (Sequence seq : seqs) {
  212 &nbsp;             if (seq.key.equals(key)) {
  213 &nbsp;                 return seq;
  214 &nbsp;             }
  215 &nbsp;         }
  216 &nbsp;         return null;
  217 &nbsp;     }
  218 &nbsp; 
  219 &nbsp;     /**
  220 &nbsp;      * @return the displayed time range in minutes, or -1 for all data
<a name='221'>  221 &nbsp;      */
  222 &nbsp;     public int getViewRange() {
  223 &nbsp;         return viewRange;
  224 &nbsp;     }
  225 &nbsp; 
  226 &nbsp;     /**
  227 &nbsp;      * @param minutes the displayed time range in minutes, or -1 to diaplay all data
  228 &nbsp;      */
  229 &nbsp;     public void setViewRange(int minutes) {
  230 &nbsp;         if (minutes != viewRange) {
<a name='231'>  231 &nbsp;             int oldValue = viewRange;
  232 &nbsp;             viewRange = minutes;
  233 &nbsp;             /* Do not i18n this string */
  234 &nbsp;             firePropertyChange("viewRange", oldValue, viewRange);
  235 &nbsp;             if (popupMenu != null) {
  236 &nbsp;                 for (int i = 0; i &lt; menuRBs.length; i++) {
  237 &nbsp;                     if (rangeValues[i] == viewRange) {
  238 &nbsp;                         menuRBs[i].setSelected(true);
  239 &nbsp;                         break;
  240 &nbsp;                     }
<a name='241'>  241 &nbsp;                 }
  242 &nbsp;             }
  243 &nbsp;             repaint();
  244 &nbsp;         }
  245 &nbsp;     }
  246 &nbsp; 
  247 &nbsp;     @Override
  248 &nbsp;     public JPopupMenu getComponentPopupMenu() {
  249 &nbsp;         if (popupMenu == null) {
  250 &nbsp;             popupMenu = new JPopupMenu(Resources.getText("Chart:"));
<a name='251'>  251 &nbsp;             timeRangeMenu = new JMenu(Resources.getText("Plotter.timeRangeMenu"));
  252 &nbsp;             timeRangeMenu.setMnemonic(getMnemonicInt("Plotter.timeRangeMenu"));
  253 &nbsp;             popupMenu.add(timeRangeMenu);
  254 &nbsp;             menuRBs = new JRadioButtonMenuItem[rangeNames.length];
  255 &nbsp;             ButtonGroup rbGroup = new ButtonGroup();
  256 &nbsp;             for (int i = 0; i &lt; rangeNames.length; i++) {
  257 &nbsp;                 menuRBs[i] = new JRadioButtonMenuItem(rangeNames[i]);
  258 &nbsp;                 rbGroup.add(menuRBs[i]);
  259 &nbsp;                 menuRBs[i].addActionListener(this);
  260 &nbsp;                 if (viewRange == rangeValues[i]) {
<a name='261'>  261 &nbsp;                     menuRBs[i].setSelected(true);
  262 &nbsp;                 }
  263 &nbsp;                 timeRangeMenu.add(menuRBs[i]);
  264 &nbsp;             }
  265 &nbsp; 
  266 &nbsp;             popupMenu.addSeparator();
  267 &nbsp; 
  268 &nbsp;             saveAsMI = new JMenuItem(getText("Plotter.saveAsMenuItem"));
  269 &nbsp;             saveAsMI.setMnemonic(getMnemonicInt("Plotter.saveAsMenuItem"));
  270 &nbsp;             saveAsMI.addActionListener(this);
<a name='271'>  271 &nbsp;             popupMenu.add(saveAsMI);
  272 &nbsp;         }
  273 &nbsp;         return popupMenu;
  274 &nbsp;     }
  275 &nbsp; 
  276 &nbsp;     public void actionPerformed(ActionEvent ev) {
  277 &nbsp;         JComponent src = (JComponent)ev.getSource();
  278 &nbsp;         if (src == saveAsMI) {
  279 &nbsp;             saveAs();
  280 &nbsp;         } else {
<a name='281'>  281 &nbsp;             int index = timeRangeMenu.getPopupMenu().getComponentIndex(src);
  282 &nbsp;             setViewRange(rangeValues[index]);
  283 &nbsp;         }
  284 &nbsp;     }
  285 &nbsp; 
  286 &nbsp;     private void saveAs() {
  287 &nbsp;         if (saveFC == null) {
  288 &nbsp;             saveFC = new SaveDataFileChooser();
  289 &nbsp;         }
  290 &nbsp;         int ret = saveFC.showSaveDialog(this);
<a name='291'>  291 &nbsp;         if (ret == JFileChooser.APPROVE_OPTION) {
  292 &nbsp;             saveDataToFile(saveFC.getSelectedFile());
  293 &nbsp;         }
  294 &nbsp;     }
  295 &nbsp; 
  296 &nbsp;     private void saveDataToFile(File file) {
  297 &nbsp;         try {
  298 &nbsp;             PrintStream out = new PrintStream(new FileOutputStream(file));
  299 &nbsp; 
  300 &nbsp;             // Print header line
<a name='301'>  301 &nbsp;             out.print("Time");
  302 &nbsp;             for (Sequence seq : seqs) {
  303 &nbsp;                 out.print(","+seq.name);
  304 &nbsp;             }
  305 &nbsp;             out.println();
  306 &nbsp; 
  307 &nbsp;             // Print data lines
  308 &nbsp;             if (seqs.size() &gt; 0 &amp;&amp; seqs.get(0).size &gt; 0) {
  309 &nbsp;                 for (int i = 0; i &lt; seqs.get(0).size; i++) {
  310 &nbsp;                     double excelTime = toExcelTime(times.time(i));
<a name='311'>  311 &nbsp;                     out.print(String.format(Locale.ENGLISH, "%.6f", excelTime));
  312 &nbsp;                     for (Sequence seq : seqs) {
  313 &nbsp;                         out.print("," + getFormattedValue(seq.value(i), false));
  314 &nbsp;                     }
  315 &nbsp;                     out.println();
  316 &nbsp;                 }
  317 &nbsp;             }
  318 &nbsp; 
  319 &nbsp;             out.close();
  320 &nbsp;             JOptionPane.showMessageDialog(this,
<a name='321'>  321 &nbsp;                                           getText("FileChooser.savedFile",
  322 &nbsp;                                                   file.getAbsolutePath(),
  323 &nbsp;                                                   file.length()));
  324 &nbsp;         } catch (IOException ex) {
  325 &nbsp;             String msg = ex.getLocalizedMessage();
  326 &nbsp;             String path = file.getAbsolutePath();
  327 &nbsp;             if (msg.startsWith(path)) {
  328 &nbsp;                 msg = msg.substring(path.length()).trim();
  329 &nbsp;             }
  330 &nbsp;             JOptionPane.showMessageDialog(this,
<a name='331'>  331 &nbsp;                                           getText("FileChooser.saveFailed.message",
  332 &nbsp;                                                   path, msg),
  333 &nbsp;                                           getText("FileChooser.saveFailed.title"),
  334 &nbsp;                                           JOptionPane.ERROR_MESSAGE);
  335 &nbsp;         }
  336 &nbsp;     }
  337 &nbsp; 
  338 &nbsp;     @Override
  339 &nbsp;     public void paintComponent(Graphics g) {
  340 &nbsp;         super.paintComponent(g);
<a name='341'>  341 &nbsp; 
  342 &nbsp;         Color oldColor = g.getColor();
  343 &nbsp;         Font  oldFont  = g.getFont();
  344 &nbsp;         Color fg = getForeground();
  345 &nbsp;         Color bg = getBackground();
  346 &nbsp;         boolean bgIsLight = (bg.getRed() &gt; 200 &amp;&amp;
  347 &nbsp;                              bg.getGreen() &gt; 200 &amp;&amp;
  348 &nbsp;                              bg.getBlue() &gt; 200);
  349 &nbsp; 
  350 &nbsp; 
<a name='351'>  351 &nbsp;         ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,
  352 &nbsp;                                          RenderingHints.VALUE_ANTIALIAS_ON);
  353 &nbsp; 
  354 &nbsp;         if (smallFont == null) {
  355 &nbsp;             smallFont = oldFont.deriveFont(9.0F);
  356 &nbsp;         }
  357 &nbsp; 
  358 &nbsp;         r.x = leftMargin - 5;
  359 &nbsp;         r.y = topMargin  - 8;
  360 &nbsp;         r.width  = getWidth()-leftMargin-rightMargin;
<a name='361'>  361 &nbsp;         r.height = getHeight()-topMargin-bottomMargin+16;
  362 &nbsp; 
  363 &nbsp;         if (border == null) {
  364 &nbsp;             // By setting colors here, we avoid recalculating them
  365 &nbsp;             // over and over.
  366 &nbsp;             border = new BevelBorder(BevelBorder.LOWERED,
  367 &nbsp;                                      getBackground().brighter().brighter(),
  368 &nbsp;                                      getBackground().brighter(),
  369 &nbsp;                                      getBackground().darker().darker(),
  370 &nbsp;                                      getBackground().darker());
<a name='371'>  371 &nbsp;         }
  372 &nbsp; 
  373 &nbsp;         border.paintBorder(this, g, r.x, r.y, r.width, r.height);
  374 &nbsp; 
  375 &nbsp;         // Fill background color
  376 &nbsp;         g.setColor(bgColor);
  377 &nbsp;         g.fillRect(r.x+2, r.y+2, r.width-4, r.height-4);
  378 &nbsp;         g.setColor(oldColor);
  379 &nbsp; 
  380 &nbsp;         long tMin = Long.MAX_VALUE;
<a name='381'>  381 &nbsp;         long tMax = Long.MIN_VALUE;
  382 &nbsp;         long vMin = Long.MAX_VALUE;
  383 &nbsp;         long vMax = 1;
  384 &nbsp; 
  385 &nbsp;         int w = getWidth()-rightMargin-leftMargin-10;
  386 &nbsp;         int h = getHeight()-topMargin-bottomMargin;
  387 &nbsp; 
  388 &nbsp;         if (times.size &gt; 1) {
  389 &nbsp;             tMin = Math.min(tMin, times.time(0));
  390 &nbsp;             tMax = Math.max(tMax, times.time(times.size-1));
<a name='391'>  391 &nbsp;         }
  392 &nbsp;         long viewRangeMS;
  393 &nbsp;         if (viewRange &gt; 0) {
  394 &nbsp;             viewRangeMS = viewRange * MINUTE;
  395 &nbsp;         } else {
  396 &nbsp;             // Display full time range, but no less than a minute
  397 &nbsp;             viewRangeMS = Math.max(tMax - tMin, 1 * MINUTE);
  398 &nbsp;         }
  399 &nbsp; 
  400 &nbsp;         // Calculate min/max values
<a name='401'>  401 &nbsp;         for (Sequence seq : seqs) {
  402 &nbsp;             if (seq.size &gt; 0) {
  403 &nbsp;                 for (int i = 0; i &lt; seq.size; i++) {
  404 &nbsp;                     if (seq.size == 1 || times.time(i) &gt;= tMax - viewRangeMS) {
  405 &nbsp;                         long val = seq.value(i);
  406 &nbsp;                         if (val &gt; Long.MIN_VALUE) {
  407 &nbsp;                             vMax = Math.max(vMax, val);
  408 &nbsp;                             vMin = Math.min(vMin, val);
  409 &nbsp;                         }
  410 &nbsp;                     }
<a name='411'>  411 &nbsp;                 }
  412 &nbsp;             } else {
  413 &nbsp;                 vMin = 0L;
  414 &nbsp;             }
  415 &nbsp;             if (unit == Unit.BYTES || !seq.isPlotted) {
  416 &nbsp;                 // We'll scale only to the first (main) value set.
  417 &nbsp;                 // TODO: Use a separate property for this.
  418 &nbsp;                 break;
  419 &nbsp;             }
  420 &nbsp;         }
<a name='421'>  421 &nbsp; 
  422 &nbsp;         // Normalize scale
  423 &nbsp;         vMax = normalizeMax(vMax);
  424 &nbsp;         if (vMin &gt; 0) {
  425 &nbsp;             if (vMax / vMin &gt; 4) {
  426 &nbsp;                 vMin = 0;
  427 &nbsp;             } else {
  428 &nbsp;                 vMin = normalizeMin(vMin);
  429 &nbsp;             }
  430 &nbsp;         }
<a name='431'>  431 &nbsp; 
  432 &nbsp; 
  433 &nbsp;         g.setColor(fg);
  434 &nbsp; 
  435 &nbsp;         // Axes
  436 &nbsp;         // Draw vertical axis
  437 &nbsp;         int x = leftMargin - 18;
  438 &nbsp;         int y = topMargin;
  439 &nbsp;         FontMetrics fm = g.getFontMetrics();
  440 &nbsp; 
<a name='441'>  441 &nbsp;         g.drawLine(x,   y,   x,   y+h);
  442 &nbsp; 
  443 &nbsp;         int n = 5;
  444 &nbsp;         if ((""+vMax).startsWith("2")) {
  445 &nbsp;             n = 4;
  446 &nbsp;         } else if ((""+vMax).startsWith("3")) {
  447 &nbsp;             n = 6;
  448 &nbsp;         } else if ((""+vMax).startsWith("4")) {
  449 &nbsp;             n = 4;
  450 &nbsp;         } else if ((""+vMax).startsWith("6")) {
<a name='451'>  451 &nbsp;             n = 6;
  452 &nbsp;         } else if ((""+vMax).startsWith("7")) {
  453 &nbsp;             n = 7;
  454 &nbsp;         } else if ((""+vMax).startsWith("8")) {
  455 &nbsp;             n = 8;
  456 &nbsp;         } else if ((""+vMax).startsWith("9")) {
  457 &nbsp;             n = 3;
  458 &nbsp;         }
  459 &nbsp; 
  460 &nbsp;         // Ticks
<a name='461'>  461 &nbsp;         ArrayList&lt;Long&gt; tickValues = new ArrayList&lt;Long&gt;();
  462 &nbsp;         tickValues.add(vMin);
  463 &nbsp;         for (int i = 0; i &lt; n; i++) {
  464 &nbsp;             long v = i * vMax / n;
  465 &nbsp;             if (v &gt; vMin) {
  466 &nbsp;                 tickValues.add(v);
  467 &nbsp;             }
  468 &nbsp;         }
  469 &nbsp;         tickValues.add(vMax);
  470 &nbsp;         n = tickValues.size();
<a name='471'>  471 &nbsp; 
  472 &nbsp;         String[] tickStrings = new String[n];
  473 &nbsp;         for (int i = 0; i &lt; n; i++) {
  474 &nbsp;             long v = tickValues.get(i);
  475 &nbsp;             tickStrings[i] = getSizeString(v, vMax);
  476 &nbsp;         }
  477 &nbsp; 
  478 &nbsp;         // Trim trailing decimal zeroes.
  479 &nbsp;         if (decimals &gt; 0) {
  480 &nbsp;             boolean trimLast = true;
<a name='481'>  481 &nbsp;             boolean removedDecimalPoint = false;
  482 &nbsp;             do {
  483 &nbsp;                 for (String str : tickStrings) {
  484 &nbsp;                     if (!(str.endsWith("0") || str.endsWith("."))) {
  485 &nbsp;                         trimLast = false;
  486 &nbsp;                         break;
  487 &nbsp;                     }
  488 &nbsp;                 }
  489 &nbsp;                 if (trimLast) {
  490 &nbsp;                     if (tickStrings[0].endsWith(".")) {
<a name='491'>  491 &nbsp;                         removedDecimalPoint = true;
  492 &nbsp;                     }
  493 &nbsp;                     for (int i = 0; i &lt; n; i++) {
  494 &nbsp;                         String str = tickStrings[i];
  495 &nbsp;                         tickStrings[i] = str.substring(0, str.length()-1);
  496 &nbsp;                     }
  497 &nbsp;                 }
  498 &nbsp;             } while (trimLast &amp;&amp; !removedDecimalPoint);
  499 &nbsp;         }
  500 &nbsp; 
<a name='501'>  501 &nbsp;         // Draw ticks
  502 &nbsp;         int lastY = Integer.MAX_VALUE;
  503 &nbsp;         for (int i = 0; i &lt; n; i++) {
  504 &nbsp;             long v = tickValues.get(i);
  505 &nbsp;             y = topMargin+h-(int)(h * (v-vMin) / (vMax-vMin));
  506 &nbsp;             g.drawLine(x-2, y, x+2, y);
  507 &nbsp;             String s = tickStrings[i];
  508 &nbsp;             if (unit == Unit.PERCENT) {
  509 &nbsp;                 s += "%";
  510 &nbsp;             }
<a name='511'>  511 &nbsp;             int sx = x-6-fm.stringWidth(s);
  512 &nbsp;             if (y &lt; lastY-13) {
  513 &nbsp;                 if (checkLeftMargin(sx)) {
  514 &nbsp;                     // Wait for next repaint
  515 &nbsp;                     return;
  516 &nbsp;                 }
  517 &nbsp;                 g.drawString(s, sx, y+4);
  518 &nbsp;             }
  519 &nbsp;             // Draw horizontal grid line
  520 &nbsp;             g.setColor(Color.lightGray);
<a name='521'>  521 &nbsp;             g.drawLine(r.x + 4, y, r.x + r.width - 4, y);
  522 &nbsp;             g.setColor(fg);
  523 &nbsp;             lastY = y;
  524 &nbsp;         }
  525 &nbsp; 
  526 &nbsp;         // Draw horizontal axis
  527 &nbsp;         x = leftMargin;
  528 &nbsp;         y = topMargin + h + 15;
  529 &nbsp;         g.drawLine(x,   y,   x+w, y);
  530 &nbsp; 
<a name='531'>  531 &nbsp;         long t1 = tMax;
  532 &nbsp;         if (t1 &lt;= 0L) {
  533 &nbsp;             // No data yet, so draw current time
  534 &nbsp;             t1 = System.currentTimeMillis();
  535 &nbsp;         }
  536 &nbsp;         long tz = timeDF.getTimeZone().getOffset(t1);
  537 &nbsp;         long tickInterval = calculateTickInterval(w, 40, viewRangeMS);
  538 &nbsp;         if (tickInterval &gt; 3 * HOUR) {
  539 &nbsp;             tickInterval = calculateTickInterval(w, 80, viewRangeMS);
  540 &nbsp;         }
<a name='541'>  541 &nbsp;         long t0 = tickInterval - (t1 - viewRangeMS + tz) % tickInterval;
  542 &nbsp;         while (t0 &lt; viewRangeMS) {
  543 &nbsp;             x = leftMargin + (int)(w * t0 / viewRangeMS);
  544 &nbsp;             g.drawLine(x, y-2, x, y+2);
  545 &nbsp; 
  546 &nbsp;             long t = t1 - viewRangeMS + t0;
  547 &nbsp;             String str = formatClockTime(t);
  548 &nbsp;             g.drawString(str, x, y+16);
  549 &nbsp;             //if (tickInterval &gt; (1 * HOUR) &amp;&amp; t % (1 * DAY) == 0) {
  550 &nbsp;             if ((t + tz) % (1 * DAY) == 0) {
<a name='551'>  551 &nbsp;                 str = formatDate(t);
  552 &nbsp;                 g.drawString(str, x, y+27);
  553 &nbsp;             }
  554 &nbsp;             // Draw vertical grid line
  555 &nbsp;             g.setColor(Color.lightGray);
  556 &nbsp;             g.drawLine(x, topMargin, x, topMargin + h);
  557 &nbsp;             g.setColor(fg);
  558 &nbsp;             t0 += tickInterval;
  559 &nbsp;         }
  560 &nbsp; 
<a name='561'>  561 &nbsp;         // Plot values
  562 &nbsp;         int start = 0;
  563 &nbsp;         int nValues = 0;
  564 &nbsp;         int nLists = seqs.size();
  565 &nbsp;         if (nLists &gt; 0) {
  566 &nbsp;             nValues = seqs.get(0).size;
  567 &nbsp;         }
  568 &nbsp;         if (nValues == 0) {
  569 &nbsp;             g.setColor(oldColor);
  570 &nbsp;             return;
<a name='571'>  571 &nbsp;         } else {
  572 &nbsp;             Sequence seq = seqs.get(0);
  573 &nbsp;             // Find starting point
  574 &nbsp;             for (int p = 0; p &lt; seq.size; p++) {
  575 &nbsp;                 if (times.time(p) &gt;= tMax - viewRangeMS) {
  576 &nbsp;                     start = p;
  577 &nbsp;                     break;
  578 &nbsp;                 }
  579 &nbsp;             }
  580 &nbsp;         }
<a name='581'>  581 &nbsp; 
  582 &nbsp;         //Optimization: collapse plot of more than four values per pixel
  583 &nbsp;         int pointsPerPixel = (nValues - start) / w;
  584 &nbsp;         if (pointsPerPixel &lt; 4) {
  585 &nbsp;             pointsPerPixel = 1;
  586 &nbsp;         }
  587 &nbsp; 
  588 &nbsp;         // Draw graphs
  589 &nbsp;         // Loop backwards over sequences because the first needs to be painted on top
  590 &nbsp;         for (int i = nLists-1; i &gt;= 0; i--) {
<a name='591'>  591 &nbsp;             int x0 = leftMargin;
  592 &nbsp;             int y0 = topMargin + h + 1;
  593 &nbsp; 
  594 &nbsp;             Sequence seq = seqs.get(i);
  595 &nbsp;             if (seq.isPlotted &amp;&amp; seq.size &gt; 0) {
  596 &nbsp;                 // Paint twice, with white and with color
  597 &nbsp;                 for (int pass = 0; pass &lt; 2; pass++) {
  598 &nbsp;                     g.setColor((pass == 0) ? Color.white : seq.color);
  599 &nbsp;                     int x1 = -1;
  600 &nbsp;                     long v1 = -1;
<a name='601'>  601 &nbsp;                     for (int p = start; p &lt; nValues; p += pointsPerPixel) {
  602 &nbsp;                         // Make sure we get the last value
  603 &nbsp;                         if (pointsPerPixel &gt; 1 &amp;&amp; p &gt;= nValues - pointsPerPixel) {
  604 &nbsp;                             p = nValues - 1;
  605 &nbsp;                         }
  606 &nbsp;                         int x2 = (int)(w * (times.time(p)-(t1-viewRangeMS)) / viewRangeMS);
  607 &nbsp;                         long v2 = seq.value(p);
  608 &nbsp;                         if (v2 &gt;= vMin &amp;&amp; v2 &lt;= vMax) {
  609 &nbsp;                             int y2  = (int)(h * (v2 -vMin) / (vMax-vMin));
  610 &nbsp;                             if (x1 &gt;= 0 &amp;&amp; v1 &gt;= vMin &amp;&amp; v1 &lt;= vMax) {
<a name='611'>  611 &nbsp;                                 int y1 = (int)(h * (v1-vMin) / (vMax-vMin));
  612 &nbsp; 
  613 &nbsp;                                 if (y1 == y2) {
  614 &nbsp;                                     // fillrect is much faster
  615 &nbsp;                                     g.fillRect(x0+x1, y0-y1-pass, x2-x1, 1);
  616 &nbsp;                                 } else {
  617 &nbsp;                                     Graphics2D g2d = (Graphics2D)g;
  618 &nbsp;                                     Stroke oldStroke = null;
  619 &nbsp;                                     if (seq.transitionStroke != null) {
  620 &nbsp;                                         oldStroke = g2d.getStroke();
<a name='621'>  621 &nbsp;                                         g2d.setStroke(seq.transitionStroke);
  622 &nbsp;                                     }
  623 &nbsp;                                     g.drawLine(x0+x1, y0-y1-pass, x0+x2, y0-y2-pass);
  624 &nbsp;                                     if (oldStroke != null) {
  625 &nbsp;                                         g2d.setStroke(oldStroke);
  626 &nbsp;                                     }
  627 &nbsp;                                 }
  628 &nbsp;                             }
  629 &nbsp;                         }
  630 &nbsp;                         x1 = x2;
<a name='631'>  631 &nbsp;                         v1 = v2;
  632 &nbsp;                     }
  633 &nbsp;                 }
  634 &nbsp; 
  635 &nbsp;                 // Current value
  636 &nbsp;                 long v = seq.value(seq.size - 1);
  637 &nbsp;                 if (v &gt;= vMin &amp;&amp; v &lt;= vMax) {
  638 &nbsp;                     if (bgIsLight) {
  639 &nbsp;                         g.setColor(seq.color);
  640 &nbsp;                     } else {
<a name='641'>  641 &nbsp;                         g.setColor(fg);
  642 &nbsp;                     }
  643 &nbsp;                     x = r.x + r.width + 2;
  644 &nbsp;                     y = topMargin+h-(int)(h * (v-vMin) / (vMax-vMin));
  645 &nbsp;                     // a small triangle/arrow
  646 &nbsp;                     g.fillPolygon(new int[] { x+2, x+6, x+6 },
  647 &nbsp;                                   new int[] { y,   y+3, y-3 },
  648 &nbsp;                                   3);
  649 &nbsp;                 }
  650 &nbsp;                 g.setColor(fg);
<a name='651'>  651 &nbsp;             }
  652 &nbsp;         }
  653 &nbsp; 
  654 &nbsp;         int[] valueStringSlots = new int[nLists];
  655 &nbsp;         for (int i = 0; i &lt; nLists; i++) valueStringSlots[i] = -1;
  656 &nbsp;         for (int i = 0; i &lt; nLists; i++) {
  657 &nbsp;             Sequence seq = seqs.get(i);
  658 &nbsp;             if (seq.isPlotted &amp;&amp; seq.size &gt; 0) {
  659 &nbsp;                 // Draw current value
  660 &nbsp; 
<a name='661'>  661 &nbsp;                 // TODO: collapse values if pointsPerPixel &gt;= 4
  662 &nbsp; 
  663 &nbsp;                 long v = seq.value(seq.size - 1);
  664 &nbsp;                 if (v &gt;= vMin &amp;&amp; v &lt;= vMax) {
  665 &nbsp;                     x = r.x + r.width + 2;
  666 &nbsp;                     y = topMargin+h-(int)(h * (v-vMin) / (vMax-vMin));
  667 &nbsp;                     int y2 = getValueStringSlot(valueStringSlots, y, 2*10, i);
  668 &nbsp;                     g.setFont(smallFont);
  669 &nbsp;                     if (bgIsLight) {
  670 &nbsp;                         g.setColor(seq.color);
<a name='671'>  671 &nbsp;                     } else {
  672 &nbsp;                         g.setColor(fg);
  673 &nbsp;                     }
  674 &nbsp;                     String curValue = getFormattedValue(v, true);
  675 &nbsp;                     if (unit == Unit.PERCENT) {
  676 &nbsp;                         curValue += "%";
  677 &nbsp;                     }
  678 &nbsp;                     int valWidth = fm.stringWidth(curValue);
  679 &nbsp;                     String legend = (displayLegend?seq.name:"");
  680 &nbsp;                     int legendWidth = fm.stringWidth(legend);
<a name='681'>  681 &nbsp;                     if (checkRightMargin(valWidth) || checkRightMargin(legendWidth)) {
  682 &nbsp;                         // Wait for next repaint
  683 &nbsp;                         return;
  684 &nbsp;                     }
  685 &nbsp;                     g.drawString(legend  , x + 17, Math.min(topMargin+h,      y2 + 3 - 10));
  686 &nbsp;                     g.drawString(curValue, x + 17, Math.min(topMargin+h + 10, y2 + 3));
  687 &nbsp; 
  688 &nbsp;                     // Maybe draw a short line to value
  689 &nbsp;                     if (y2 &gt; y + 3) {
  690 &nbsp;                         g.drawLine(x + 9, y + 2, x + 14, y2);
<a name='691'>  691 &nbsp;                     } else if (y2 &lt; y - 3) {
  692 &nbsp;                         g.drawLine(x + 9, y - 2, x + 14, y2);
  693 &nbsp;                     }
  694 &nbsp;                 }
  695 &nbsp;                 g.setFont(oldFont);
  696 &nbsp;                 g.setColor(fg);
  697 &nbsp; 
  698 &nbsp;             }
  699 &nbsp;         }
  700 &nbsp;         g.setColor(oldColor);
<a name='701'>  701 &nbsp;     }
  702 &nbsp; 
  703 &nbsp;     private boolean checkLeftMargin(int x) {
  704 &nbsp;         // Make sure leftMargin has at least 2 pixels over
  705 &nbsp;         if (x &lt; 2) {
  706 &nbsp;             leftMargin += (2 - x);
  707 &nbsp;             // Repaint from top (above any cell renderers)
  708 &nbsp;             SwingUtilities.getWindowAncestor(this).repaint();
  709 &nbsp;             return true;
  710 &nbsp;         }
<a name='711'>  711 &nbsp;         return false;
  712 &nbsp;     }
  713 &nbsp; 
  714 &nbsp;     private boolean checkRightMargin(int w) {
  715 &nbsp;         // Make sure rightMargin has at least 2 pixels over
  716 &nbsp;         if (w + 2 &gt; rightMargin) {
  717 &nbsp;             rightMargin = (w + 2);
  718 &nbsp;             // Repaint from top (above any cell renderers)
  719 &nbsp;             SwingUtilities.getWindowAncestor(this).repaint();
  720 &nbsp;             return true;
<a name='721'>  721 &nbsp;         }
  722 &nbsp;         return false;
  723 &nbsp;     }
  724 &nbsp; 
  725 &nbsp;     private int getValueStringSlot(int[] slots, int y, int h, int i) {
  726 &nbsp;         for (int s = 0; s &lt; slots.length; s++) {
  727 &nbsp;             if (slots[s] &gt;= y &amp;&amp; slots[s] &lt; y + h) {
  728 &nbsp;                 // collide below us
  729 &nbsp;                 if (slots[s] &gt; h) {
  730 &nbsp;                     return getValueStringSlot(slots, slots[s]-h, h, i);
<a name='731'>  731 &nbsp;                 } else {
  732 &nbsp;                     return getValueStringSlot(slots, slots[s]+h, h, i);
  733 &nbsp;                 }
  734 &nbsp;             } else if (y &gt;= h &amp;&amp; slots[s] &gt; y - h &amp;&amp; slots[s] &lt; y) {
  735 &nbsp;                 // collide above us
  736 &nbsp;                 return getValueStringSlot(slots, slots[s]+h, h, i);
  737 &nbsp;             }
  738 &nbsp;         }
  739 &nbsp;         slots[i] = y;
  740 &nbsp;         return y;
<a name='741'>  741 &nbsp;     }
  742 &nbsp; 
  743 &nbsp;     private long calculateTickInterval(int w, int hGap, long viewRangeMS) {
  744 &nbsp;         long tickInterval = viewRangeMS * hGap / w;
  745 &nbsp;         if (tickInterval &lt; 1 * MINUTE) {
  746 &nbsp;             tickInterval = 1 * MINUTE;
  747 &nbsp;         } else if (tickInterval &lt; 5 * MINUTE) {
  748 &nbsp;             tickInterval = 5 * MINUTE;
  749 &nbsp;         } else if (tickInterval &lt; 10 * MINUTE) {
  750 &nbsp;             tickInterval = 10 * MINUTE;
<a name='751'>  751 &nbsp;         } else if (tickInterval &lt; 30 * MINUTE) {
  752 &nbsp;             tickInterval = 30 * MINUTE;
  753 &nbsp;         } else if (tickInterval &lt; 1 * HOUR) {
  754 &nbsp;             tickInterval = 1 * HOUR;
  755 &nbsp;         } else if (tickInterval &lt; 3 * HOUR) {
  756 &nbsp;             tickInterval = 3 * HOUR;
  757 &nbsp;         } else if (tickInterval &lt; 6 * HOUR) {
  758 &nbsp;             tickInterval = 6 * HOUR;
  759 &nbsp;         } else if (tickInterval &lt; 12 * HOUR) {
  760 &nbsp;             tickInterval = 12 * HOUR;
<a name='761'>  761 &nbsp;         } else if (tickInterval &lt; 1 * DAY) {
  762 &nbsp;             tickInterval = 1 * DAY;
  763 &nbsp;         } else {
  764 &nbsp;             tickInterval = normalizeMax(tickInterval / DAY) * DAY;
  765 &nbsp;         }
  766 &nbsp;         return tickInterval;
  767 &nbsp;     }
  768 &nbsp; 
  769 &nbsp;     private long normalizeMin(long l) {
  770 &nbsp;         int exp = (int)Math.log10((double)l);
<a name='771'>  771 &nbsp;         long multiple = (long)Math.pow(10.0, exp);
  772 &nbsp;         int i = (int)(l / multiple);
  773 &nbsp;         return i * multiple;
  774 &nbsp;     }
  775 &nbsp; 
  776 &nbsp;     private long normalizeMax(long l) {
  777 &nbsp;         int exp = (int)Math.log10((double)l);
  778 &nbsp;         long multiple = (long)Math.pow(10.0, exp);
  779 &nbsp;         int i = (int)(l / multiple);
  780 &nbsp;         l = (i+1)*multiple;
<a name='781'>  781 &nbsp;         return l;
  782 &nbsp;     }
  783 &nbsp; 
  784 &nbsp;     private String getFormattedValue(long v, boolean groupDigits) {
  785 &nbsp;         String str;
  786 &nbsp;         String fmt = "%";
  787 &nbsp;         if (groupDigits) {
  788 &nbsp;             fmt += ",";
  789 &nbsp;         }
  790 &nbsp;         if (decimals &gt; 0) {
<a name='791'>  791 &nbsp;             fmt += "." + decimals + "f";
  792 &nbsp;             str = String.format(fmt, v / decimalsMultiplier);
  793 &nbsp;         } else {
  794 &nbsp;             fmt += "d";
  795 &nbsp;             str = String.format(fmt, v);
  796 &nbsp;         }
  797 &nbsp;         return str;
  798 &nbsp;     }
  799 &nbsp; 
  800 &nbsp;     private String getSizeString(long v, long vMax) {
<a name='801'>  801 &nbsp;         String s;
  802 &nbsp; 
  803 &nbsp;         if (unit == Unit.BYTES &amp;&amp; decimals == 0) {
  804 &nbsp;             s = formatBytes(v, vMax);
  805 &nbsp;         } else {
  806 &nbsp;             s = getFormattedValue(v, true);
  807 &nbsp;         }
  808 &nbsp;         return s;
  809 &nbsp;     }
  810 &nbsp; 
<a name='811'>  811 &nbsp;     private static synchronized Stroke getDashedStroke() {
  812 &nbsp;         if (dashedStroke == null) {
  813 &nbsp;             dashedStroke = new BasicStroke(1.0f,
  814 &nbsp;                                            BasicStroke.CAP_BUTT,
  815 &nbsp;                                            BasicStroke.JOIN_MITER,
  816 &nbsp;                                            10.0f,
  817 &nbsp;                                            new float[] { 2.0f, 3.0f },
  818 &nbsp;                                            0.0f);
  819 &nbsp;         }
  820 &nbsp;         return dashedStroke;
<a name='821'>  821 &nbsp;     }
  822 &nbsp; 
  823 &nbsp;     private static Object extendArray(Object a1) {
  824 &nbsp;         int n = Array.getLength(a1);
  825 &nbsp;         Object a2 =
  826 &nbsp;             Array.newInstance(a1.getClass().getComponentType(),
  827 &nbsp;                               n + ARRAY_SIZE_INCREMENT);
  828 &nbsp;         System.arraycopy(a1, 0, a2, 0, n);
  829 &nbsp;         return a2;
  830 &nbsp;     }
<a name='831'>  831 &nbsp; 
  832 &nbsp; 
  833 &nbsp;     private static class TimeStamps {
  834 &nbsp;         // Time stamps (long) are split into offsets (long) and a
  835 &nbsp;         // series of times from the offsets (int). A new offset is
  836 &nbsp;         // stored when the the time value doesn't fit in an int
  837 &nbsp;         // (approx every 24 days).  An array of indices is used to
  838 &nbsp;         // define the starting point for each offset in the times
  839 &nbsp;         // array.
  840 &nbsp;         long[] offsets = new long[0];
<a name='841'>  841 &nbsp;         int[] indices = new int[0];
  842 &nbsp;         int[] rtimes = new int[ARRAY_SIZE_INCREMENT];
  843 &nbsp; 
  844 &nbsp;         // Number of stored timestamps
  845 &nbsp;         int size = 0;
  846 &nbsp; 
  847 &nbsp;         /**
  848 &nbsp;          * Returns the time stamp for index i
  849 &nbsp;          */
  850 &nbsp;         public long time(int i) {
<a name='851'>  851 &nbsp;             long offset = 0;
  852 &nbsp;             for (int j = indices.length - 1; j &gt;= 0; j--) {
  853 &nbsp;                 if (i &gt;= indices[j]) {
  854 &nbsp;                     offset = offsets[j];
  855 &nbsp;                     break;
  856 &nbsp;                 }
  857 &nbsp;             }
  858 &nbsp;             return offset + rtimes[i];
  859 &nbsp;         }
  860 &nbsp; 
<a name='861'>  861 &nbsp;         public void add(long time) {
  862 &nbsp;             // May need to store a new time offset
  863 &nbsp;             int n = offsets.length;
  864 &nbsp;             if (n == 0 || time - offsets[n - 1] &gt; Integer.MAX_VALUE) {
  865 &nbsp;                 // Grow offset and indices arrays and store new offset
  866 &nbsp;                 offsets = Arrays.copyOf(offsets, n + 1);
  867 &nbsp;                 offsets[n] = time;
  868 &nbsp;                 indices = Arrays.copyOf(indices, n + 1);
  869 &nbsp;                 indices[n] = size;
  870 &nbsp;             }
<a name='871'>  871 &nbsp; 
  872 &nbsp;             // May need to extend the array size
  873 &nbsp;             if (rtimes.length == size) {
  874 &nbsp;                 rtimes = (int[])extendArray(rtimes);
  875 &nbsp;             }
  876 &nbsp; 
  877 &nbsp;             // Store the time
  878 &nbsp;             rtimes[size]  = (int)(time - offsets[offsets.length - 1]);
  879 &nbsp;             size++;
  880 &nbsp;         }
<a name='881'>  881 &nbsp;     }
  882 &nbsp; 
  883 &nbsp;     private static class Sequence {
  884 &nbsp;         String key;
  885 &nbsp;         String name;
  886 &nbsp;         Color color;
  887 &nbsp;         boolean isPlotted;
  888 &nbsp;         Stroke transitionStroke = null;
  889 &nbsp; 
  890 &nbsp;         // Values are stored in an int[] if all values will fit,
<a name='891'>  891 &nbsp;         // otherwise in a long[]. An int can represent up to 2 GB.
  892 &nbsp;         // Use a random start size, so all arrays won't need to
  893 &nbsp;         // be grown during the same update interval
  894 &nbsp;         Object values =
  895 &nbsp;             new byte[ARRAY_SIZE_INCREMENT + (int)(Math.random() * 100)];
  896 &nbsp; 
  897 &nbsp;         // Number of stored values
  898 &nbsp;         int size = 0;
  899 &nbsp; 
  900 &nbsp;         public Sequence(String key) {
<a name='901'>  901 &nbsp;             this.key = key;
  902 &nbsp;         }
  903 &nbsp; 
  904 &nbsp;         /**
  905 &nbsp;          * Returns the value at index i
  906 &nbsp;          */
  907 &nbsp;         public long value(int i) {
  908 &nbsp;             return Array.getLong(values, i);
  909 &nbsp;         }
  910 &nbsp; 
<a name='911'>  911 &nbsp;         public void add(long value) {
  912 &nbsp;             // May need to switch to a larger array type
  913 &nbsp;             if ((values instanceof byte[] ||
  914 &nbsp;                  values instanceof short[] ||
  915 &nbsp;                  values instanceof int[]) &amp;&amp;
  916 &nbsp;                        value &gt; Integer.MAX_VALUE) {
  917 &nbsp;                 long[] la = new long[Array.getLength(values)];
  918 &nbsp;                 for (int i = 0; i &lt; size; i++) {
  919 &nbsp;                     la[i] = Array.getLong(values, i);
  920 &nbsp;                 }
<a name='921'>  921 &nbsp;                 values = la;
  922 &nbsp;             } else if ((values instanceof byte[] ||
  923 &nbsp;                         values instanceof short[]) &amp;&amp;
  924 &nbsp;                        value &gt; Short.MAX_VALUE) {
  925 &nbsp;                 int[] ia = new int[Array.getLength(values)];
  926 &nbsp;                 for (int i = 0; i &lt; size; i++) {
  927 &nbsp;                     ia[i] = Array.getInt(values, i);
  928 &nbsp;                 }
  929 &nbsp;                 values = ia;
  930 &nbsp;             } else if (values instanceof byte[] &amp;&amp;
<a name='931'>  931 &nbsp;                        value &gt; Byte.MAX_VALUE) {
  932 &nbsp;                 short[] sa = new short[Array.getLength(values)];
  933 &nbsp;                 for (int i = 0; i &lt; size; i++) {
  934 &nbsp;                     sa[i] = Array.getShort(values, i);
  935 &nbsp;                 }
  936 &nbsp;                 values = sa;
  937 &nbsp;             }
  938 &nbsp; 
  939 &nbsp;             // May need to extend the array size
  940 &nbsp;             if (Array.getLength(values) == size) {
<a name='941'>  941 &nbsp;                 values = extendArray(values);
  942 &nbsp;             }
  943 &nbsp; 
  944 &nbsp;             // Store the value
  945 &nbsp;             if (values instanceof long[]) {
  946 &nbsp;                 ((long[])values)[size] = value;
  947 &nbsp;             } else if (values instanceof int[]) {
  948 &nbsp;                 ((int[])values)[size] = (int)value;
  949 &nbsp;             } else if (values instanceof short[]) {
  950 &nbsp;                 ((short[])values)[size] = (short)value;
<a name='951'>  951 &nbsp;             } else {
  952 &nbsp;                 ((byte[])values)[size] = (byte)value;
  953 &nbsp;             }
  954 &nbsp;             size++;
  955 &nbsp;         }
  956 &nbsp;     }
  957 &nbsp; 
  958 &nbsp;     // Can be overridden by subclasses
  959 &nbsp;     long getValue() {
  960 &nbsp;         return 0;
<a name='961'>  961 &nbsp;     }
  962 &nbsp; 
  963 &nbsp;     long getLastTimeStamp() {
  964 &nbsp;         return times.time(times.size - 1);
  965 &nbsp;     }
  966 &nbsp; 
  967 &nbsp;     long getLastValue(String key) {
  968 &nbsp;         Sequence seq = getSequence(key);
  969 &nbsp;         return (seq != null &amp;&amp; seq.size &gt; 0) ? seq.value(seq.size - 1) : 0L;
  970 &nbsp;     }
<a name='971'>  971 &nbsp; 
  972 &nbsp; 
  973 &nbsp;     // Called on EDT
  974 &nbsp;     public void propertyChange(PropertyChangeEvent ev) {
  975 &nbsp;         String prop = ev.getPropertyName();
  976 &nbsp; 
  977 &nbsp;         if (prop == JConsoleContext.CONNECTION_STATE_PROPERTY) {
  978 &nbsp;             ConnectionState newState = (ConnectionState)ev.getNewValue();
  979 &nbsp; 
  980 &nbsp;             switch (newState) {
<a name='981'>  981 &nbsp;               case DISCONNECTED:
  982 &nbsp;                 synchronized(this) {
  983 &nbsp;                     long time = System.currentTimeMillis();
  984 &nbsp;                     times.add(time);
  985 &nbsp;                     for (Sequence seq : seqs) {
  986 &nbsp;                         seq.add(Long.MIN_VALUE);
  987 &nbsp;                     }
  988 &nbsp;                 }
  989 &nbsp;                 break;
  990 &nbsp;             }
<a name='991'>  991 &nbsp;         }
  992 &nbsp;     }
  993 &nbsp; 
  994 &nbsp;     private static class SaveDataFileChooser extends JFileChooser {
  995 &nbsp;         private static final long serialVersionUID = -5182890922369369669L;
  996 &nbsp;         SaveDataFileChooser() {
  997 &nbsp;             setFileFilter(new FileNameExtensionFilter("CSV file", "csv"));
  998 &nbsp;         }
  999 &nbsp; 
 1000 &nbsp;         @Override
<a name='1001'> 1001 &nbsp;         public void approveSelection() {
 1002 &nbsp;             File file = getSelectedFile();
 1003 &nbsp;             if (file != null) {
 1004 &nbsp;                 FileFilter filter = getFileFilter();
 1005 &nbsp;                 if (filter != null &amp;&amp; filter instanceof FileNameExtensionFilter) {
 1006 &nbsp;                     String[] extensions =
 1007 &nbsp;                         ((FileNameExtensionFilter)filter).getExtensions();
 1008 &nbsp; 
 1009 &nbsp;                     boolean goodExt = false;
 1010 &nbsp;                     for (String ext : extensions) {
<a name='1011'> 1011 &nbsp;                         if (file.getName().toLowerCase().endsWith("." + ext.toLowerCase())) {
 1012 &nbsp;                             goodExt = true;
 1013 &nbsp;                             break;
 1014 &nbsp;                         }
 1015 &nbsp;                     }
 1016 &nbsp;                     if (!goodExt) {
 1017 &nbsp;                         file = new File(file.getParent(),
 1018 &nbsp;                                         file.getName() + "." + extensions[0]);
 1019 &nbsp;                     }
 1020 &nbsp;                 }
<a name='1021'> 1021 &nbsp; 
 1022 &nbsp;                 if (file.exists()) {
 1023 &nbsp;                     String okStr = getText("FileChooser.fileExists.okOption");
 1024 &nbsp;                     String cancelStr = getText("FileChooser.fileExists.cancelOption");
 1025 &nbsp;                     int ret =
 1026 &nbsp;                         JOptionPane.showOptionDialog(this,
 1027 &nbsp;                                                      getText("FileChooser.fileExists.message",
 1028 &nbsp;                                                              file.getName()),
 1029 &nbsp;                                                      getText("FileChooser.fileExists.title"),
 1030 &nbsp;                                                      JOptionPane.OK_CANCEL_OPTION,
<a name='1031'> 1031 &nbsp;                                                      JOptionPane.WARNING_MESSAGE,
 1032 &nbsp;                                                      null,
 1033 &nbsp;                                                      new Object[] { okStr, cancelStr },
 1034 &nbsp;                                                      okStr);
 1035 &nbsp;                     if (ret != JOptionPane.OK_OPTION) {
 1036 &nbsp;                         return;
 1037 &nbsp;                     }
 1038 &nbsp;                 }
 1039 &nbsp;                 setSelectedFile(file);
 1040 &nbsp;             }
<a name='1041'> 1041 &nbsp;             super.approveSelection();
 1042 &nbsp;         }
 1043 &nbsp;     }
 1044 &nbsp; 
 1045 &nbsp;     @Override
 1046 &nbsp;     public AccessibleContext getAccessibleContext() {
 1047 &nbsp;         if (accessibleContext == null) {
 1048 &nbsp;             accessibleContext = new AccessiblePlotter();
 1049 &nbsp;         }
 1050 &nbsp;         return accessibleContext;
<a name='1051'> 1051 &nbsp;     }
 1052 &nbsp; 
 1053 &nbsp;     protected class AccessiblePlotter extends AccessibleJComponent {
 1054 &nbsp;         private static final long serialVersionUID = -3847205410473510922L;
 1055 &nbsp;         protected AccessiblePlotter() {
 1056 &nbsp;             setAccessibleName(getText("Plotter.accessibleName"));
 1057 &nbsp;         }
 1058 &nbsp; 
 1059 &nbsp;         @Override
 1060 &nbsp;         public String getAccessibleName() {
<a name='1061'> 1061 &nbsp;             String name = super.getAccessibleName();
 1062 &nbsp; 
 1063 &nbsp;             if (seqs.size() &gt; 0 &amp;&amp; seqs.get(0).size &gt; 0) {
 1064 &nbsp;                 String keyValueList = "";
 1065 &nbsp;                 for (Sequence seq : seqs) {
 1066 &nbsp;                     if (seq.isPlotted) {
 1067 &nbsp;                         String value = "null";
 1068 &nbsp;                         if (seq.size &gt; 0) {
 1069 &nbsp;                             if (unit == Unit.BYTES) {
 1070 &nbsp;                                 value = getText("Size Bytes", seq.value(seq.size - 1));
<a name='1071'> 1071 &nbsp;                             } else {
 1072 &nbsp;                                 value =
 1073 &nbsp;                                     getFormattedValue(seq.value(seq.size - 1), false) +
 1074 &nbsp;                                     ((unit == Unit.PERCENT) ? "%" : "");
 1075 &nbsp;                             }
 1076 &nbsp;                         }
 1077 &nbsp;                         // Assume format string ends with newline
 1078 &nbsp;                         keyValueList +=
 1079 &nbsp;                             getText("Plotter.accessibleName.keyAndValue",
 1080 &nbsp;                                     seq.key, value);
<a name='1081'> 1081 &nbsp;                     }
 1082 &nbsp;                 }
 1083 &nbsp;                 name += "\n" + keyValueList + ".";
 1084 &nbsp;             } else {
 1085 &nbsp;                 name += "\n" + getText("Plotter.accessibleName.noData");
 1086 &nbsp;             }
 1087 &nbsp;             return name;
 1088 &nbsp;         }
 1089 &nbsp; 
 1090 &nbsp;         @Override
<a name='1091'> 1091 &nbsp;         public AccessibleRole getAccessibleRole() {
 1092 &nbsp;             return AccessibleRole.CANVAS;
 1093 &nbsp;         }
 1094 &nbsp;     }
 1095 &nbsp; }

</pre>
<div style="width:100%;background-color:#ddeeff;border:1px solid #ccddee;margin:0 0 0 0;padding:2px 2px 2px 2px">
<div style="float:right"><a href="http://del.icio.us/post" onclick="window.open('http://del.icio.us/post?v=4&noui&jump=close&url='+encodeURIComponent(location.href)+'&title='+encodeURIComponent(document.title), 'delicious','toolbar=no,width=700,height=400'); return false;"><img src="http://images.del.icio.us/static/img/delicious.small.gif" border=0> Save This Page</a></div>
<a href="/">Home</a> &#187; <a href="/projects/openjdk-7-code.html">openjdk-7</a> &#187; sun.tools &#187;  <a href='/docs/api/sun/tools/jconsole/package-index.html'>jconsole</a> &#187; 
 [<a href="/docs/api/sun/tools/jconsole/Plotter.html">javadoc</a> | source]
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-138120-1");
pageTracker._trackPageview();
</script>
</body>
</html>






<!-- end -->